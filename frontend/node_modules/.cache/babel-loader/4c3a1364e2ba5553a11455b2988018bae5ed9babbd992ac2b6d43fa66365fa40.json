{"ast":null,"code":"/*!\n * Chart.js v4.3.0\n * https://www.chartjs.org\n * (c) 2023 Chart.js Contributors\n * Released under the MIT License\n */\nimport { Color } from '@kurkle/color';\n\n/**\n * @namespace Chart.helpers\n */ /**\n    * An empty function that can be used, for example, for optional callback.\n    */\nfunction noop() {\n  /* noop */}\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nconst uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value) {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nfunction clone(source) {\n  if (isArray(source)) {\n    return source.map(clone);\n  }\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current;\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge(target, source, {\n    merger: _mergerIf\n  });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n/**\n * @private\n */\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n/**\n * @private\n */\nfunction _splitKey(key) {\n  const parts = key.split('.');\n  const keys = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\nfunction _getKeyResolver(key) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\nfunction resolveObjectKey(obj, key) {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n/**\n * @private\n */\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = value => typeof value !== 'undefined';\nconst isFunction = value => typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * @param e - The event\n * @private\n */\nfunction _isClickEvent(e) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < -0.5 * PI) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nfunction _isBetween(value, start, end) {\n  let epsilon = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-6;\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || (index => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = lo + hi >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {\n    lo,\n    hi\n  };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nconst _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? index => {\n  const ti = table[index][key];\n  return ti < value || ti === value && table[index + 1][key] === value;\n} : index => table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nconst _rlookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach(key => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach(object => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach(key => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\n/**\n * @param items\n */\nfunction _arrayUnique(items) {\n  const set = new Set(items);\n  if (set.size === items.length) {\n    return items;\n  }\n  return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/\nconst requestAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return function (callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nfunction throttled(fn, thisArg) {\n  let argsToUse = [];\n  let ticking = false;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nconst _toLeftRightCenter = align => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {\n      iScale,\n      _parsed\n    } = meta;\n    const axis = iScale.axis;\n    const {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = iScale.getUserBounds();\n    if (minDefined) {\n      start = _limitValue(Math.min(\n      // @ts-expect-error Need to type _parsed\n      _lookupByKey(_parsed, iScale.axis, min).lo,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n      // @ts-expect-error Need to type _parsed\n      _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {\n    start,\n    count\n  };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nfunction _scaleRangesChanged(meta) {\n  const {\n    xScale,\n    yScale,\n    _scaleRanges\n  } = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\nconst atEdge = t => t === 0 || t === 1;\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  },\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < 1 / d) {\n      return m * t * t;\n    }\n    if (t < 2 / d) {\n      return m * (t -= 1.5 / d) * t + 0.75;\n    }\n    if (t < 2.5 / d) {\n      return m * (t -= 2.25 / d) * t + 0.9375;\n    }\n    return m * (t -= 2.625 / d) * t + 0.984375;\n  },\n  easeInOutBounce: t => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\nfunction isPatternOrGradient(value) {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n  return false;\n}\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\nfunction applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined\n  });\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: name => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n  });\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    }\n  });\n  defaults.describe('animations', {\n    _fallback: 'animation'\n  });\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0\n        }\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0\n        }\n      }\n    }\n  });\n}\nfunction applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {\n      notation,\n      minimumFractionDigits: numDecimal,\n      maximumFractionDigits: numDecimal\n    };\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {\n  formatters\n};\nfunction applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n    bounds: 'ticks',\n    grace: 0,\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false\n    },\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n    title: {\n      display: false,\n      text: '',\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2\n    }\n  });\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: name => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: name => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n  });\n  defaults.describe('scales', {\n    _fallback: 'scale'\n  });\n  defaults.describe('scale.ticks', {\n    _scriptable: name => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: name => name !== 'backdropPadding'\n  });\n}\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n  apply(appliers) {\n    appliers.forEach(apply => apply(this));\n  }\n}\nvar defaults = /* #__PURE__ */new Defaults({\n  _scriptable: name => !name.startsWith('on'),\n  _indexable: name => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n/**\n * @private\n */\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n    // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n      // NOTE: the rounded rect implementation changed to use `arc` instead of\n      // `quadraticCurveTo` since it generates better results when rect is\n      // almost a circle. 0.516 (instead of 0.5) produces results with visually\n      // closer proportion to the previous impl and it is inscribed in the\n      // circle with `radius`. For more details, see the following PRs:\n      // https://github.com/chartjs/Chart.js/issues/5597\n      // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\n/**\n * @private\n */\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n    * Now that IE11 support has been dropped, we can use more\n    * of the TextMetrics object. The actual bounding boxes\n    * are unflagged in Chrome, Firefox, Edge, and Safari so they\n    * can be safely used.\n    * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n    */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction drawBackdrop(ctx, opts) {\n  const oldColor = ctx.fillStyle;\n  ctx.fillStyle = opts.color;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */\nfunction renderText(ctx, text, x, y, font) {\n  let opts = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += Number(font.lineHeight);\n  }\n  ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nfunction addRoundedRectPath(ctx, rect) {\n  const {\n    x,\n    y,\n    w,\n    h,\n    radius\n  } = rect;\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n    * Converts the given line height `value` in pixels for a specific font `size`.\n    * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n    * @param size - The font size (in pixels) used to resolve relative `value`.\n    * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n    * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n    * @since 2.7.0\n    */\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n  }\n  return size * value;\n}\nconst numberOrZero = v => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nfunction toTRBL(value) {\n  return _readValueToProps(value, {\n    top: 'y',\n    right: 'x',\n    bottom: 'y',\n    left: 'x'\n  });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {\n    min,\n    max\n  } = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nfunction _createResolver(scopes) {\n  let prefixes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [''];\n  let rootScopes = arguments.length > 2 ? arguments[2] : undefined;\n  let fallback = arguments.length > 3 ? arguments[3] : undefined;\n  let getTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : () => scopes[0];\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: scope => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback)\n  };\n  return new Proxy(cache, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get(target, prop) {\n      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get(target, prop, receiver) {\n      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n        enumerable: true,\n        configurable: true\n      } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  });\n}\n/**\n * @private\n */\nfunction _descriptors(proxy) {\n  let defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    scriptable: true,\n    indexable: true\n  };\n  const {\n    _scriptable = defaults.scriptable,\n    _indexable = defaults.indexable,\n    _allKeys = defaults.allKeys\n  } = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors\n  } = target;\n  let value = _proxy[prop]; // resolve from proxy\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _stack\n  } = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors\n  } = target;\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent) => key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback, () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n  const {\n    iScale\n  } = meta;\n  const {\n    key = 'r'\n  } = this._parsing;\n  const parsed = new Array(count);\n  let i, ilen, index, item;\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = indexAxis => indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n  // This function must also respect \"skipped\" points\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK) {\n  let indexAxis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'x';\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nfunction splineCurveMonotone(points) {\n  let indexAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n/**\n * @private\n */\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter(pt => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */ /**\n    * @private\n    */\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nconst getComputedStyle = element => element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(e, canvas) {\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {\n    offsetX,\n    offsetY\n  } = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {\n    x,\n    y,\n    box\n  };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\nfunction getRelativePosition(event, chart) {\n  if ('native' in event) {\n    return event;\n  }\n  const {\n    canvas,\n    currentDevicePixelRatio\n  } = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {\n    x,\n    y,\n    box\n  } = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {\n    width,\n    height\n  } = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nconst round1 = v => Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {\n    width,\n    height\n  } = containerSize;\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n  return {\n    width,\n    height\n  };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = Math.floor(chart.height);\n  chart.width = Math.floor(chart.width);\n  const canvas = chart.canvas;\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nconst supportsEventListenerOptions = function () {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n/**\n * @private\n */\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n  };\n}\n/**\n * @private\n */\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {\n    x: p1.cp2x,\n    y: p1.cp2y\n  };\n  const cp2 = {\n    x: p2.cp1x,\n    y: p2.cp1y\n  };\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\nconst getRightToLeftAdapter = function (rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    }\n  };\n};\nconst getLeftToRightAdapter = function () {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {},\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    }\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\nfunction normalizeSegment(_ref) {\n  let {\n    start,\n    end,\n    count,\n    loop,\n    style\n  } = _ref;\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const {\n    between,\n    normalize\n  } = propertyFn(property);\n  const count = points.length;\n  let {\n    start,\n    end,\n    loop\n  } = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {\n    start,\n    end,\n    loop,\n    style: segment.style\n  };\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const count = points.length;\n  const {\n    compare,\n    between,\n    normalize\n  } = propertyFn(property);\n  const {\n    start,\n    end,\n    loop,\n    style\n  } = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({\n        start: subStart,\n        end: i,\n        loop,\n        count,\n        style\n      }));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({\n      start: subStart,\n      end,\n      loop,\n      count,\n      style\n    }));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {\n    start,\n    end\n  };\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({\n          start: start % count,\n          end: (end - 1) % count,\n          loop\n        });\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({\n      start: start % count,\n      end: last % count,\n      loop\n    });\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {\n    start,\n    end\n  } = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{\n      start,\n      end,\n      loop\n    }], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {\n    _datasetIndex: datasetIndex,\n    options: {\n      spanGaps\n    }\n  } = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({\n        start: s % count,\n        end: e % count,\n        loop: l,\n        style: st\n      });\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function (key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\nexport { unclipArea as $, _rlookupByKey as A, _lookupByKey as B, _isPointInArea as C, getAngleFromPoint as D, toPadding as E, each as F, getMaximumSize as G, HALF_PI as H, _getParentNode as I, readUsedSize as J, supportsEventListenerOptions as K, throttled as L, _isDomSupported as M, _factorize as N, finiteOrDefault as O, PI as P, callback as Q, _addGrace as R, _limitValue as S, TAU as T, toDegrees as U, _measureText as V, _int16Range as W, _alignPixel as X, clipArea as Y, renderText as Z, _arrayUnique as _, resolve as a, fontString as a$, toFont as a0, _toLeftRightCenter as a1, _alignStartEnd as a2, overrides as a3, merge as a4, _capitalize as a5, descriptors as a6, isFunction as a7, _attachContext as a8, _createResolver as a9, overrideTextDirection as aA, _textX as aB, restoreTextDirection as aC, drawPointLegend as aD, distanceBetweenPoints as aE, noop as aF, _setMinAndMaxByKey as aG, niceNum as aH, almostWhole as aI, almostEquals as aJ, _decimalPlaces as aK, Ticks as aL, log10 as aM, _longestText as aN, _filterBetween as aO, _lookup as aP, isPatternOrGradient as aQ, getHoverColor as aR, clone as aS, _merger as aT, _mergerIf as aU, _deprecated as aV, _splitKey as aW, toFontString as aX, splineCurve as aY, splineCurveMonotone as aZ, getStyle as a_, _descriptors as aa, mergeIf as ab, uid as ac, debounce as ad, retinaScale as ae, clearCanvas as af, setsEqual as ag, _elementsEqual as ah, _isClickEvent as ai, _isBetween as aj, _readValueToProps as ak, _updateBezierControlPoints as al, _computeSegments as am, _boundSegments as an, _steppedInterpolation as ao, _bezierInterpolation as ap, _pointInLine as aq, _steppedLineTo as ar, _bezierCurveTo as as, drawPoint as at, addRoundedRectPath as au, toTRBL as av, toTRBLCorners as aw, _boundSegment as ax, _normalizeAngle as ay, getRtlAdapter as az, isArray as b, toLineHeight as b0, PITAU as b1, INFINITY as b2, RAD_PER_DEG as b3, QUARTER_PI as b4, TWO_THIRDS_PI as b5, _angleDiff as b6, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, defined as h, isObject as i, createContext as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, getRelativePosition as z };","map":{"version":3,"mappings":"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","names":["noop","uid","id","isNullOrUndef","value","isArray","Array","type","Object","prototype","toString","call","slice","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toPercentage","dimension","endsWith","parseFloat","toDimension","callback","fn","args","thisArg","apply","each","loopable","reverse","i","len","keys","length","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","index","clone","source","map","target","create","klen","k","isValidKey","key","indexOf","_merger","options","tval","sval","merge","sources","merger","current","mergeIf","_mergerIf","hasOwnProperty","_deprecated","scope","previous","undefined","console","warn","keyResolvers","v","x","o","y","_splitKey","parts","split","tmp","part","push","_getKeyResolver","obj","resolveObjectKey","resolver","_capitalize","str","charAt","toUpperCase","defined","isFunction","setsEqual","a","b","size","item","has","_isClickEvent","e","PI","Math","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","abs","niceNum","range","roundedRange","round","niceRange","pow","floor","fraction","niceFraction","_factorize","result","sqrt","sort","pop","isNumber","n","isNaN","almostWhole","rounded","_setMinAndMaxByKey","array","property","min","max","toRadians","degrees","toDegrees","radians","_decimalPlaces","isFiniteNumber","p","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","start","end","sameAngleIsFullCircle","s","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_int16Range","_isBetween","_lookup","table","cmp","hi","lo","mid","_lookupByKey","last","ti","_rlookupByKey","_filterBetween","values","arrayEvents","listenArrayEvents","listener","_chartjs","listeners","defineProperty","configurable","enumerable","forEach","method","base","res","object","unlistenArrayEvents","stub","splice","_arrayUnique","items","set","Set","from","fontString","pixelSize","fontStyle","fontFamily","requestAnimFrame","window","requestAnimationFrame","throttled","argsToUse","ticking","debounce","delay","timeout","clearTimeout","setTimeout","_toLeftRightCenter","align","_alignStartEnd","_textX","left","right","rtl","check","_getStartAndCountOfVisiblePoints","meta","points","animationsDisabled","pointCount","count","_sorted","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","_scaleRangesChanged","xScale","yScale","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","assign","atEdge","t","elasticIn","sin","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","m","d","easeInOutBounce","isPatternOrGradient","color","Color","getHoverColor","saturate","darken","hexString","numbers","colors","applyAnimationsDefaults","defaults","duration","easing","loop","to","describe","_fallback","_indexable","_scriptable","name","properties","active","animation","resize","show","animations","visible","hide","applyLayoutsDefaults","autoPadding","padding","top","bottom","intlCache","Map","getNumberFormat","locale","cacheKey","JSON","stringify","formatter","get","Intl","NumberFormat","formatNumber","num","format","formatters","numeric","tickValue","ticks","chart","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","includes","applyScaleDefaults","display","offset","beginAtZero","bounds","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","Ticks","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","route","startsWith","overrides","descriptors","getScope","node","root","Defaults","constructor","_descriptors","_appliers","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","weight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","override","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","local","appliers","toFontString","_measureText","data","gc","longest","string","textWidth","measureText","_longestText","arrayOfThings","cache","garbageCollect","save","j","jlen","thing","nestedThing","restore","gcLen","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","resetTransform","clearRect","height","drawPoint","drawPointLegend","w","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","rotate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","_isPointInArea","point","area","margin","clipArea","clip","unclipArea","_steppedLineTo","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","setRenderOpts","opts","translation","fillStyle","textAlign","textBaseline","decorateText","line","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","strokeStyle","decorationWidth","drawBackdrop","oldColor","fillRect","renderText","lines","strokeWidth","strokeColor","backdrop","strokeText","maxWidth","fillText","addRoundedRectPath","h","topLeft","bottomLeft","bottomRight","topRight","LINE_HEIGHT","FONT_STYLE","toLineHeight","matches","match","numberOrZero","_readValueToProps","props","ret","objProps","read","prop","toTRBL","toTRBLCorners","toPadding","toFont","fallback","parseInt","resolve","inputs","info","cacheable","_addGrace","minmax","change","keepZero","add","createContext","parentContext","_createResolver","scopes","prefixes","rootScopes","getTarget","finalRootScopes","_resolve","Symbol","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","_keys","_cached","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getPrototypeOf","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","proxy","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","setContext","receiver","_resolveWithContext","allKeys","scriptable","indexable","_allKeys","isScriptable","isIndexable","readKey","prefix","needsSubResolver","_resolveScriptable","_resolveArray","getValue","Error","join","delete","createSubResolver","arr","filter","resolveFallback","parent","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","_parsing","parsed","r","parse","EPSILON","getPoint","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","next","d01","d12","s01","s12","fa","fb","monotoneAdjust","deltaK","mK","pointsLen","alphaK","betaK","tauK","squaredMagnitude","pointCurrent","pointAfter","monotoneCompute","valueAxis","pointBefore","iPixel","vPixel","splineCurveMonotone","slopeDelta","capControlPoint","pt","capBezierPoints","inArea","inAreaPrev","inAreaNext","_updateBezierControlPoints","controlPoints","spanGaps","cubicInterpolationMode","prev","tension","_isDomSupported","document","_getParentNode","domNode","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","ownerDocument","defaultView","getStyle","el","getPropertyValue","positions","getPositionedStyle","styles","suffix","pos","useOffsetPos","shadowRoot","getCanvasPosition","touches","offsetX","offsetY","box","getBoundingClientRect","clientX","clientY","getRelativePosition","event","borderBox","boxSizing","paddings","borders","getContainerSize","maxHeight","container","clientWidth","clientHeight","containerStyle","containerBorder","containerPadding","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","containerSize","maintainHeight","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","_pointInLine","p1","p2","_steppedInterpolation","_bezierInterpolation","cp1","cp2","c","getRightToLeftAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","getLeftToRightAdapter","_itemWidth","getRtlAdapter","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","getSegment","segment","startBound","endBound","_boundSegment","inside","subStart","prevValue","startIsBefore","endIsBefore","shouldStart","shouldStop","_boundSegments","segments","sub","findStartAndEnd","solidSegments","cur","stop","_computeSegments","segmentOptions","_loop","splitByStyles","completeLoop","_fullLoop","doSplitByStyles","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","l","st","dir","p0","p0DataIndex","p1DataIndex","styleChanged","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","replacer"],"sources":["E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.core.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.math.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.collection.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.extras.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.easing.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.color.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\core\\core.animations.defaults.js","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\core\\core.layouts.defaults.js","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.intl.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\core\\core.ticks.js","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\core\\core.scale.defaults.js","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\core\\core.defaults.js","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.canvas.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.options.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.config.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.curve.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.dom.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.interpolation.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.rtl.ts","E:\\Leinah\\Documents\\GitHub\\BudgeBuddy\\frontend\\node_modules\\chart.js\\src\\helpers\\helpers.segment.js"],"sourcesContent":["/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || typeof value === 'undefined';\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type Chart from '../core/core.controller.js';\nimport type {ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  chart.height = Math.floor(chart.height);\n  chart.width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}